{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>yang terbaik intinya drink  and </p> hello.cpp<pre><code>include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello kawan\" &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>"},{"location":"#data-baru","title":"data baru","text":"Linked listLinked forward listIni adalah ciruclas linked list <p>ini linked list</p> <p>ini adalah linked forward list</p> <p>Halo, ini jendela yang berbeda</p>"},{"location":"#semoga-bisa","title":"semoga bisa","text":"yang baru saja terjadi <p>aku tidak tahu apakah ini bisa atau tidak, tapi semoga bisa</p>"},{"location":"#flowchart","title":"flowchart","text":"<pre><code>graph LR\n    A[Start] --&gt; B{Failure?};\n    B --&gt;|Yes| C[Investigate...];\n    C --&gt; D[Debug];\n    D --&gt; B;\n    B ----&gt;|No| E[Succes!];</code></pre> \\[ \\cos x=\\sum_{k=0}^{\\infty}\\frac{(-1)^k}{(2k)!}x^{2k} \\]"},{"location":"Linked-List/Linked-List/","title":"Linked List","text":"<p>Link sumber: Linked List Data Structure</p>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Linked-List/#linked-list-data-structure","title":"Linked list Data Structure","text":"<p>Sebuah linked list adalah struktur data (data structure) linear yang menyertakan serangkaian node yang saling terhubung. Di sini, setiap node menyimpan data dan alamat (address) dari node berikutnya. Sebagai contoh,</p> <p>![[04-Data Structure/Z-src/Linked list Data Structure (Programmiz)-1.png]]</p> <p>Kita harus memulai dari suatu tempat, sehingga kita memberikan alamat (address) dari node pertama sebuah nama khusus yang disebut <code>HEAD</code>. Selain itu, node terakhir dalam linked list dapat diidentifikasi karena bagian <code>next</code>-nya menunjuk ke <code>NULL</code>.</p> <p>Linked list dapat terdiri dari berbagai jenis: singly linked list (list berantai tunggal), doubly linked list (list berantai ganda), dan circular linked list (list berantai melingkar). Dalam artikel ini, kita akan berfokus pada singly linked list. Untuk mempelajari jenis-jenis lain, kunjungi Types of Linked List.</p> <p>Catatan: Anda mungkin pernah memainkan permainan Perburuan Harta Karun (Treasure Hunt), di mana setiap petunjuk mencakup informasi mengenai petunjuk berikutnya. Begitulah cara linked list beroperasi.</p>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Linked-List/#1-representasi-linked-list","title":"1 | Representasi Linked List","text":"<p>Mari kita lihat bagaimana setiap node dari linked list direpresentasikan. Setiap node terdiri dari:</p> <ul> <li>Sebuah item data</li> <li>Sebuah alamat (address) dari node lain</li> </ul> <p>Kita membungkus baik item data maupun referensi node berikutnya dalam sebuah <code>struct</code> sebagai berikut:</p> <pre><code>struct node {\n  int data;\n  struct node *next;\n};\n</code></pre> <p>Memahami struktur (structure) sebuah node linked list adalah kunci untuk memahami keseluruhan konsepnya.</p> <p>Setiap <code>struct node</code> memiliki sebuah item data dan sebuah pointer ke <code>struct node</code> lain. Mari kita buat sebuah Linked List sederhana dengan tiga item untuk memahami cara kerjanya.</p> <pre><code>/* Inisialisasi node */\nstruct node *head;\nstruct node *one = NULL;\nstruct node *two = NULL;\nstruct node *three = NULL;\n\n/* Alokasikan memori */\none = malloc(sizeof(struct node));\ntwo = malloc(sizeof(struct node));\nthree = malloc(sizeof(struct node));\n\n/* Tetapkan nilai data */\none-&gt;data = 1;\ntwo-&gt;data = 2;\nthree-&gt;data=3;\n\n/* Hubungkan node */\none-&gt;next = two;\ntwo-&gt;next = three;\nthree-&gt;next = NULL;\n\n/* Simpan alamat dari node pertama pada head */\nhead = one;\n</code></pre> <p>Jika Anda tidak memahami salah satu baris di atas, yang Anda butuhkan hanyalah penyegaran ulang mengenai pointer dan struct.</p> <p>Hanya dalam beberapa langkah, kita telah membuat sebuah linked list sederhana dengan tiga node.</p> <p>![[Linked list Data Structure (Programmiz)-2.png]]</p> <p>Kekuatan linked list berasal dari kemampuan untuk memutus rantai dan menyambungkannya kembali. Misalnya, jika Anda ingin menyisipkan elemen 4 di antara 1 dan 2, langkah-langkahnya adalah:</p> <ol> <li>Buat <code>struct node</code> baru dan alokasikan memori untuknya.</li> <li>Tambahkan nilai data-nya sebagai 4.</li> <li>Arahkan pointer <code>next</code>-nya ke <code>struct node</code> yang berisi nilai data 2.</li> <li>Ubah pointer <code>next</code> dari \"1\" ke node yang baru saja kita buat.</li> </ol> <p>Melakukan hal serupa pada array akan memerlukan pergeseran posisi semua elemen berikutnya. Sedangkan pada linked list, bisa dilakukan dengan kompleksitas yang konstan.</p> <p>Dalam Python dan Java, linked list dapat diimplementasikan menggunakan class. Dalam C++, linked list juga bisa diimplementasikan menggunakan class, hanya saja pada contoh kali ini, kita menggunakan struct.</p>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Linked-List/#2-utilitas-linked-list","title":"2 | Utilitas Linked List","text":"<p>List adalah salah satu struktur data (data structure) yang paling populer dan efisien, dengan implementasi di setiap bahasa pemrograman seperti C, C++, Python, Java, dan C#.</p> <p>Selain itu, linked list adalah cara yang bagus untuk mempelajari cara kerja pointer. Dengan mempraktikkan cara memanipulasi linked list, Anda dapat mempersiapkan diri untuk mempelajari struktur data (data structure) yang lebih lanjut seperti graf (graphs) dan trees (pohon).</p>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Linked-List/#3-implementasi-linked-list","title":"3 | Implementasi Linked List","text":"<p>Berikut adalah implementasi linked list dengan menggunakan bahasa C++:</p> <pre><code>// Implementasi linked list dalam C++\n\n#include &lt;bits/stdc++.h&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Membuat sebuah node\nclass Node {\n   public:\n  int value;\n  Node* next;\n};\n\nint main() {\n  Node* head;\n  Node* one = NULL;\n  Node* two = NULL;\n  Node* three = NULL;\n\n  // alokasikan 3 node di heap\n  one = new Node();\n  two = new Node();\n  three = new Node();\n\n  // Tetapkan nilai value\n  one-&gt;value = 1;\n  two-&gt;value = 2;\n  three-&gt;value = 3;\n\n  // Hubungkan node\n  one-&gt;next = two;\n  two-&gt;next = three;\n  three-&gt;next = NULL;\n\n  // cetak nilai (value) linked list\n  head = one;\n  while (head != NULL) {\n    cout &lt;&lt; head-&gt;value;\n    head = head-&gt;next;\n  }\n}\n</code></pre>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Linked-List/#4-kompleksitas-linked-list","title":"4 | Kompleksitas Linked List","text":"<p>Kompleksitas waktu (time complexity):</p> Operasi Kasus Terburuk (Worst Case) Kasus Rata-Rata (Average Case) Pencarian (Search) \\(O(n)\\) \\(O(n)\\) Penyisipan (Insert) \\(O(1)\\) \\(O(1)\\) Penghapusan (Deletion) \\(O(1)\\) \\(O(1)\\) Kompleksitas ruang (space complexity): \\(O(n)\\)","tags":["data-structure","linked-list"]},{"location":"Linked-List/Linked-List/#5-aplikasi-linked-list","title":"5 | Aplikasi Linked List","text":"<ul> <li>Alokasi memori dinamis (Dynamic memory allocation)</li> <li>Diimplementasikan dalam stack dan queue (antrean)</li> <li>Dalam fungsi Undo pada perangkat lunak (software)</li> <li>Hash tables dan Graf (Graphs)</li> </ul>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Singly-Linked-List/","title":"Singly Linked List","text":"<p>Link sumber: - Singly Linked List Tutorial - GeeksforGeeks - Linked List Data Structure - GeeksforGeeks</p>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Singly-Linked-List/#singly-linked-list","title":"Singly Linked List","text":"<p>Singly linked list adalah sebuah struktur data (data structure) fundamental. Struktur ini terdiri dari node, di mana setiap node berisi field data dan sebuah referensi ke node berikutnya di dalam linked list. Referensi <code>next</code> pada node terakhir adalah <code>null</code>, yang menandakan akhir dari list. Linked list mendukung operasi penyisipan (insertion) dan penghapusan (deletion) yang efisien.</p> <p>![[Singly Linked List-1.png]]</p>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Singly-Linked-List/#1-pemahaman-struktur-node","title":"1 | Pemahaman Struktur Node","text":"<p>Dalam sebuah singly linked list, setiap node terdiri dari dua bagian: data dan sebuah pointer ke node berikutnya. Struktur ini memungkinkan node dihubungkan bersama secara dinamis (dynamically linked), membentuk sebuah urutan yang menyerupai rantai.</p> <pre><code>// Definisi sebuah Node dalam singly linked list\nclass Node {\n\npublic:\n    // Bagian data dari node\n    int data;\n\n    // Pointer ke node berikutnya dalam list\n    Node* next;\n\n    // Konstruktor untuk menginisialisasi node dengan data\n    Node(int data) {\n        this-&gt;data = data;\n        this-&gt;next = NULL;\n    }\n};\n</code></pre> <p>Dalam contoh ini, <code>class Node</code> berisi field data bertipe integer untuk menyimpan informasi dan sebuah pointer ke Node lain (<code>next</code>) untuk membangun link ke node berikutnya dalam list.</p>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Singly-Linked-List/#2-membuat-contoh-linked-list-berukuran-3-untuk-memahami-cara-kerja","title":"2 | Membuat Contoh Linked List Berukuran 3 untuk Memahami Cara Kerja","text":"<p>Buat node pertama: - Alokasikan memori untuk node pertama dan simpan data di dalamnya. - Tandai node ini sebagai <code>head</code>.</p> <p>Buat node kedua:</p> <ul> <li>Alokasikan memori untuk node kedua dan simpan data di dalamnya.</li> <li>Link-kan <code>next</code> dari node pertama ke node baru ini.</li> </ul> <p>Buat node ketiga:</p> <ul> <li>Alokasikan memori untuk node ketiga dan simpan data di dalamnya.</li> <li>Link-kan <code>next</code> dari node kedua ke node ini.</li> <li>Atur <code>next</code>-nya menjadi <code>NULL</code> untuk memastikan bahwa <code>next</code> dari node terakhir adalah <code>NULL</code>.</li> </ul> <p>Berikut adalah contoh implementasi:</p> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\n// Struktur node singly linked list\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    // Konstruktor untuk menginisialisasi node baru dengan data\n    Node(int new_data) {\n        this-&gt;data = new_data;\n        this-&gt;next = nullptr;\n    }\n};\n\nint main() {\n\n    // Buat node pertama (head dari list)\n    Node* head = new Node(10);\n\n    // Hubungkan node kedua\n    head-&gt;next = new Node(20);\n\n    // Hubungkan node ketiga\n    head-&gt;next-&gt;next = new Node(30);\n\n    // Hubungkan node keempat\n    head-&gt;next-&gt;next-&gt;next = new Node(40);\n\n    // Mencetak linked list\n    while (head != nullptr) {\n        cout &lt;&lt; head-&gt;data &lt;&lt; \" \";\n        head = head-&gt;next;\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>10 20 30 40\n</code></pre>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Singly-Linked-List/#3-aplikasi-linked-list","title":"3 | Aplikasi Linked List","text":"<ul> <li>Polynomial Arithmetic (Aritmetika Polinomial)</li> </ul> <p>Linked list sangat berguna untuk merepresentasikan polinomial karena ukuran dan kompleksitasnya yang dinamis. Setiap node dapat menyimpan satu suku (koefisien dan eksponen) dari polinomial, dan karena polinomial dapat memiliki jumlah suku yang bervariasi\u2014bahkan bisa sangat jarang (sparse)\u2014linked list memungkinkan penambahan atau penghapusan suku secara efisien tanpa perlu mengalokasikan ulang seluruh struktur. Hal ini mempermudah operasi seperti penambahan atau perkalian polinomial, karena hanya suku-suku yang ada saja yang disimpan dan diproses.</p> <ul> <li>Sparse Matrix (Matriks Jarang)</li> </ul> <p>Dalam komputasi, matriks yang didominasi oleh nilai nol disebut matriks jarang (sparse matrix). Menggunakan array biasa untuk matriks semacam ini akan membuang memori yang besar. Linked list (terutama doubly linked list atau kombinasi array dan linked list) memungkinkan kita untuk menyimpan hanya elemen-elemen bukan nol (non-zero elements) beserta indeks baris dan kolomnya. Pendekatan ini secara drastis mengurangi kebutuhan memori dan dapat mempercepat operasi tertentu, seperti traversal pada elemen-elemen yang signifikan.</p> <ul> <li>Browser History Navigation (Navigasi Riwayat Browser)</li> </ul> <p>Saat Anda menavigasi riwayat laman web (tombol Back dan Forward), doubly linked list adalah struktur data (data structure) yang ideal. Setiap halaman web yang dikunjungi menjadi sebuah node, dan karena doubly linked list memiliki pointer ke node sebelumnya (<code>prev</code>) dan node berikutnya (<code>next</code>), perpindahan antara halaman yang baru dikunjungi dan yang lama menjadi sangat cepat, hanya membutuhkan waktu.</p> <ul> <li>Undo / Redo (Batalkan / Ulangi)</li> </ul> <p>Fungsi Undo (Batalkan) dan Redo (Ulangi) dalam perangkat lunak, seperti pengolah kata atau editor grafis, sering diimplementasikan menggunakan dua stack atau sebuah doubly linked list. Setiap tindakan pengguna yang dapat dibatalkan disimpan sebagai sebuah node. Jika menggunakan doubly linked list, perpindahan maju (Redo) dan mundur (Undo) pada urutan operasi sangat mudah dilakukan dengan memindahkan pointer saat ini (<code>current pointer</code>) ke node <code>prev</code> atau <code>next</code>, yang menjamin respons yang cepat.</p> <ul> <li>Text Editor (Editor Teks)</li> </ul> <p>Meskipun editor teks modern menggunakan struktur yang lebih kompleks seperti Ropes atau Gap Buffers, linked list adalah dasar yang kuat, terutama untuk penyisipan dan penghapusan karakter/kata yang efisien. Karena linked list tidak memerlukan pergeseran seluruh blok memori seperti array statis, editor teks yang menggunakan linked list dapat menangani penambahan atau penghapusan teks di tengah dokumen dengan lebih cepat (atau lebih tepatnya, waktu eksekusinya lebih konsisten) dibandingkan array murni.</p> <ul> <li>Social Media Feeds (Umpan Media Sosial)</li> </ul> <p>Umpan media sosial, seperti lini masa di X (sebelumnya Twitter) atau Instagram, pada dasarnya adalah daftar konten yang terus bertambah. Karena postingan atau konten baru terus ditambahkan ke bagian atas atau bawah daftar secara real-time, linked list sangat cocok karena kemudahannya untuk penyisipan di awal atau akhir (insertion at the head or tail). Ini memastikan bahwa feed Anda dapat di-update dengan cepat tanpa harus mereplikasi ulang seluruh daftar konten yang sudah ada.</p>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Singly-Linked-List/#4-keunggulan-dan-kelemahan","title":"4 | Keunggulan dan Kelemahan","text":"","tags":["data-structure","linked-list"]},{"location":"Linked-List/Singly-Linked-List/#41-keunggulan-advantage","title":"4.1 | Keunggulan (Advantage)","text":"<ul> <li> <p>Ukuran dinamis (Dynamic size): Tidak ada batas ukuran tetap seperti pada array.</p> </li> <li> <p>Penyisipan dan penghapusan yang efisien: Operasi penyisipan (insertion) dan penghapusan (deletion) efisien pada awal dan akhir list. Penyisipan di tengah juga efisien jika kita sudah memiliki referensi atau pointer ke node setelah node mana kita perlu menyisipkan.</p> </li> <li> <p>Dapat mengimplementasikan struktur data kompleks: Dapat digunakan untuk mengimplementasikan struktur data (data structure) yang lebih kompleks seperti stack, queue, dan graph.</p> </li> </ul>","tags":["data-structure","linked-list"]},{"location":"Linked-List/Singly-Linked-List/#42-kelemahan-disadvantage","title":"4.2 | Kelemahan (Disadvantage)","text":"<ul> <li> <p>Memori ekstra diperlukan: Diperlukan memori tambahan untuk menyimpan pointer (<code>next</code>) di setiap node.</p> </li> <li> <p>Tidak ada akses langsung/acak (No direct/random access): Memerlukan traversal (penjelajahan) dari awal (<code>head</code>) untuk mencapai node tertentu.</p> </li> <li> <p>Tidak ramah cache (Cache unfriendly): Node tidak disimpan dalam memori yang berdekatan (contiguous memory), sehingga kurang efisien dalam pemanfaatan cache prosesor.</p> </li> </ul>","tags":["data-structure","linked-list"]}]}